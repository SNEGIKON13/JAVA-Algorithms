# Java-Algorithms

Sonarcloud: https://sonarcloud.io/project/overview?id=SNEGIKON13_Java-Algorithms

[![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=SNEGIKON13_Java-Algorithms&metric=ncloc)](https://sonarcloud.io/summary/new_code?id=SNEGIKON13_Java-Algorithms)
[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=SNEGIKON13_Java-Algorithms&metric=code_smells)](https://sonarcloud.io/summary/new_code?id=SNEGIKON13_Java-Algorithms)
[![Bugs](https://sonarcloud.io/api/project_badges/measure?project=SNEGIKON13_Java-Algorithms&metric=bugs)](https://sonarcloud.io/summary/new_code?id=SNEGIKON13_Java-Algorithms)

# Задания
### 1.3 Контейнеры, очереди, стеки
+ **Задача 11** 
	 1. Условие: 
Напишите программу EvaluatePostfix, которая принимает из стандартного
ввода постфиксное выражение, вычисляет его и выводит результат. (Передача
по конвейеру выходных данных программы из nредыдущеrо упражнения на
вход этой программы эквивалентно поведению класса Evaluate.)
     2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_11)
	 3. Времени запланировано: 20 минут
	 4. Времени потрачено: 100 минут
+ **Задача 15** 
	 1. Условие: Напишите клиент класса Queue, который принимает в командной строке аргумент
k и выводит k-тую с конуа строку из введенных из стандартного ввода
(предполагается , что стандартный ввод содержит k или более строк).
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_15)
	 3. Времени запланировано: 25 минут
	 4. Времени потрачено: 35 минут
+ **Задача 26** 
     1. Условие:
Напишите метод remove(), который принимает в качестве аргументов связный
список и строку key и удаляет из списка все узлы, содержащие в поле элемента
значение key.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_26)
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 35 минут
+ **Задача 50**  
     1. Условие: Итератор с быстрым сбоем. Измените код итератора для класса Stack так, чтобы
он немедленно генерировал исключение java.util.ConcurrentModificationException,
если в процессе итерации клиент изменяет коллекцию с помощью операций push() или рор(). 
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_50)
	 3. Времени запланировано: 20 минут
	 4. Времени потрачено: 34 минуты
     
### 2.5 Применение сортировок
+ **Задача 14**
     1. Условие: Напишите тип данных Domain, представляющий
доменные имена и содержащий метод compareTo(), который реализует естественный
для доменных имен порядок обратиых имен. Например, для домена
cs.princeton.edu обратным именем будет edu.princeton.cs. Это удобно
для анализа журналов работы в Интернете. Совет: для разбиения строки s на
фрагменты, разделяемые точками, используйте вызов s.split("\\. " ). Напишите
клиент, который читает имена доменов из стандартного ввода и выводит упорядоченный
список обратных доменных имен.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_14)
	 3. Времени запланировано: 50 минут
	 4. Времени потрачено: 75 минут
+ **Задача 17**  
     1. Условие: Проверка устойчивости. Расширьте метод check() из упражнения 2.1.16 так,
	 чтобы он вызывал метод sort() для указанного массива и возвращал true, если метод sort()
	 выполняет устойчивую сортировку, и false в противном случае. Предполагается, что метод sort()
	 не перемещает элементы массива с помощью метода exch():
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_17)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 45 минут
+ **Задача 27** 
     1. Условие: Сортировка параллельных массивов.
	 При сортировке параллельных массивов удобно иметь версию процедуры сортировки,
	 которая возвращает перестановку (например, индексы) и сохраняет исходный массив.
	 В программу необходимо добавить метод indirectSort(), основанный на сортировке
	 вставками (Insertion sort), который принимает массив а[] объектов Comparable в качестве
	 аргумента. Вместо переупорядочения элементов а[], метод должен вернуть целочисленный
	 массив index[], такой, что элементы а[index[0]] до а[index[N-1]] упорядочены по возрастанию.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_27) 
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 40 минут
+ **Задача 30** 
     1. Условие: Сортировка файлов по размеру и дате последнего изменения. Напишите компараторы
для типа File, которые позволяют сортировать файлы по возрастанию/
убыванию их размера, по возрастанию/убыванию их имен и по возрастанию/
убыванию их даты последнего изменения. Используйте эти компараторы в программе
LS, которая принимает из командной строки имя каталога и выводит
имена всех находящяхся там файлов, упорядоченные по заданному критерию -
например, по отметке времени при наличии нарамстра "-t". Программа должна
поддерживатъ несколько параметров для более точного упорядочения и использовать
устойчивую сортировку.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_30)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 2 часа
	
### 3.2 Деревья бинарного поиска

+ **Задача 6**
     1. Условие: Добавьте в класс BST метод height() для вычисления высоты дерева. Разработайте
две реализации: рекурсивный метод (требующий линейного времени и
памяти, пропорциональной высоте) и метод наподобие size(), для работы которого
нужно дополнительное поле в каждом узле дерева (требующий линейного
объема памяти и константного времени на запрос).
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task_6)
	 3. Времени запланировано: 30 минут
	 4. Времени потрачено: 20 минут
+ **Задача 17**  
     1. Условие: Нарисуйте последовательность деревьев бинарного поиска, которые получаются
при поочередном удалении ключей из дерева из упражнения 3.2.1 в порядке их
вставки.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task_17)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 50 минут
+ **Задача 25** 
     1. Условие: Идеальная балансировка. Напишите программу, которая вставляет набор ключей
в первоначально пустое ДБП так, что полученное дерево эквивалентно бинарному
поиску - т.е. последовательность сравнений, выполняемых при поиске
любого ключа в ДБП, совпадает с последовательностью сравнений, выполняемых
при бинарном поиске в том же наборе ключей.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task_25) 
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 55 минут
+ **Задача 28** 
     1. Условие: Программное кеширование. Добавьте в класс BST сохранение в переменной экземпляра
узла, к которому было последнее обращение, чтобы в него можно
было попасть за константное время, если операция put() или get() повторно
использует тот же ключ (см. упражнение 3.1.25).
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task_28)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 90 минут

### 3.3 Сбалансированные деревья поиска

+ **Задача 31**
     1. Условие:  Вычерчивание дерева. Добавьте в класс RedBlackBST метод draw(), который вычерчивает
красно-черные ДБП в том же стиле, который применяется в тексте
(см. упражнение 3.2.38).
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_31)
	 3. Времени запланировано: 50 минут
	 4. Времени потрачено: 45 минут
+ **Задача 33**  
     1. Условие: Проверка. Добавьте в класс RedBlackBST метод is23() для выполнения проверки,
что ни у одного узла нет двух красных ссылок и нет правых красных
ссылок, и метод isBalanced() для выполнения проверки, что все пути от корня
к нулевым ссылкам содержат одинаковое количество черных ссылок. Объедините
эти методы с кодом isBST() из упражнения 3.2.32, чтобы получить метод
isRedBlackBST(), который проверяет, что дерево является красно-черным
деревом бинарного поиска.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_33)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 1 час
+ **Задача 39** 
     1. Условие: Удаление минимального. Реализуйте операцию deleteMin() для красно-черных
ДБП, используя преобразования, описанные в тексте, для спуска по левому
пути дерева и поддерживая инвариант, что текущий узел не является 2-узлом.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_39) 
	 3. Времени запланировано: 35 минут
	 4. Времени потрачено: 50 минут
+ **Задача 42** 
     1. Условие: Подсчет красных узлов. Напишите программу, которая вычисляет процент красных
узлов в заданном красно-черном ДБП. Проверьте работу программы, выполнив,
по крайней мере, 100 раз вставку N случайных ключей в первоначально
пустое дерево, для N = 104, 105 и 106, и сформулируйте гипотезу.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_42)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 50 минут

### 3.4 Хеш-таблицы
### 5.1 Сортировка строк
### 5.2 Trie-деревья
### 5.3 Поиск подстрок
### 5.4 Регулярные выражения