# Java-Algorithms

Sonarcloud: https://sonarcloud.io/project/overview?id=SNEGIKON13_Java-Algorithms

[![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=SNEGIKON13_Java-Algorithms&metric=ncloc)](https://sonarcloud.io/summary/new_code?id=SNEGIKON13_Java-Algorithms)
[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=SNEGIKON13_Java-Algorithms&metric=code_smells)](https://sonarcloud.io/summary/new_code?id=SNEGIKON13_Java-Algorithms)
[![Bugs](https://sonarcloud.io/api/project_badges/measure?project=SNEGIKON13_Java-Algorithms&metric=bugs)](https://sonarcloud.io/summary/new_code?id=SNEGIKON13_Java-Algorithms)

# Задания
### 1.3 Контейнеры, очереди, стеки
+ **Задача 11** 
	 1. Условие: 
Напишите программу EvaluatePostfix, которая принимает из стандартного
ввода постфиксное выражение, вычисляет его и выводит результат. (Передача
по конвейеру выходных данных программы из nредыдущеrо упражнения на
вход этой программы эквивалентно поведению класса Evaluate.)
     2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_11)
	 3. Времени запланировано: 20 минут
	 4. Времени потрачено: 100 минут
+ **Задача 15** 
	 1. Условие: Напишите клиент класса Queue, который принимает в командной строке аргумент
k и выводит k-тую с конуа строку из введенных из стандартного ввода
(предполагается , что стандартный ввод содержит k или более строк).
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_15)
	 3. Времени запланировано: 25 минут
	 4. Времени потрачено: 35 минут
+ **Задача 26** 
     1. Условие:
Напишите метод remove(), который принимает в качестве аргументов связный
список и строку key и удаляет из списка все узлы, содержащие в поле элемента
значение key.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_26)
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 35 минут
+ **Задача 50**  
     1. Условие: Итератор с быстрым сбоем. Измените код итератора для класса Stack так, чтобы
он немедленно генерировал исключение java.util.ConcurrentModificationException,
если в процессе итерации клиент изменяет коллекцию с помощью операций push() или рор(). 
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_1.3/task_50)
	 3. Времени запланировано: 20 минут
	 4. Времени потрачено: 34 минуты
     
### 2.5 Применение сортировок
+ **Задача 14**
     1. Условие: Напишите тип данных Domain, представляющий
доменные имена и содержащий метод compareTo(), который реализует естественный
для доменных имен порядок обратиых имен. Например, для домена
cs.princeton.edu обратным именем будет edu.princeton.cs. Это удобно
для анализа журналов работы в Интернете. Совет: для разбиения строки s на
фрагменты, разделяемые точками, используйте вызов s.split("\\. " ). Напишите
клиент, который читает имена доменов из стандартного ввода и выводит упорядоченный
список обратных доменных имен.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_14)
	 3. Времени запланировано: 50 минут
	 4. Времени потрачено: 75 минут
+ **Задача 17**  
     1. Условие: Проверка устойчивости. Расширьте метод check() из упражнения 2.1.16 так,
	 чтобы он вызывал метод sort() для указанного массива и возвращал true, если метод sort()
	 выполняет устойчивую сортировку, и false в противном случае. Предполагается, что метод sort()
	 не перемещает элементы массива с помощью метода exch():
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_17)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 45 минут
+ **Задача 27** 
     1. Условие: Сортировка параллельных массивов.
	 При сортировке параллельных массивов удобно иметь версию процедуры сортировки,
	 которая возвращает перестановку (например, индексы) и сохраняет исходный массив.
	 В программу необходимо добавить метод indirectSort(), основанный на сортировке
	 вставками (Insertion sort), который принимает массив а[] объектов Comparable в качестве
	 аргумента. Вместо переупорядочения элементов а[], метод должен вернуть целочисленный
	 массив index[], такой, что элементы а[index[0]] до а[index[N-1]] упорядочены по возрастанию.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_27) 
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 40 минут
+ **Задача 30** 
     1. Условие: Сортировка файлов по размеру и дате последнего изменения. Напишите компараторы
для типа File, которые позволяют сортировать файлы по возрастанию/
убыванию их размера, по возрастанию/убыванию их имен и по возрастанию/
убыванию их даты последнего изменения. Используйте эти компараторы в программе
LS, которая принимает из командной строки имя каталога и выводит
имена всех находящяхся там файлов, упорядоченные по заданному критерию -
например, по отметке времени при наличии нарамстра "-t". Программа должна
поддерживатъ несколько параметров для более точного упорядочения и использовать
устойчивую сортировку.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_2.5/task_30)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 2 часа
	
### 3.2 Деревья бинарного поиска

+ **Задача 6**
     1. Условие: Добавьте в класс BST метод height() для вычисления высоты дерева. Разработайте
две реализации: рекурсивный метод (требующий линейного времени и
памяти, пропорциональной высоте) и метод наподобие size(), для работы которого
нужно дополнительное поле в каждом узле дерева (требующий линейного
объема памяти и константного времени на запрос).
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task_6)
	 3. Времени запланировано: 30 минут
	 4. Времени потрачено: 20 минут
+ **Задача 20**  
     1. Условие: Докажите, что время выполнения метода keys() с двумя аргументами в ДБП из
N узлов не более чем пропорциональна высоте дерева плюс количество ключей
в диапазоне.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task__20)
	 3. Времени запланировано: 50 минут
	 4. Времени потрачено: 40 минут
+ **Задача 25** 
     1. Условие: Идеальная балансировка. Напишите программу, которая вставляет набор ключей
в первоначально пустое ДБП так, что полученное дерево эквивалентно бинарному
поиску - т.е. последовательность сравнений, выполняемых при поиске
любого ключа в ДБП, совпадает с последовательностью сравнений, выполняемых
при бинарном поиске в том же наборе ключей.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task_25) 
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 55 минут
+ **Задача 28** 
     1. Условие: Проверка бинарного дерева. Напишите рекурсивный метод isBinaryTree(), коrорый
принимает в качестве аргумента узел Node и возвращает true, если счетчик
узлов N для поддерева с указанным корнем верен, и false в противном случае.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.2/task_29)
	 3. Времени запланировано: 30 минут
	 4. Времени потрачено: 25 минут

### 3.3 Сбалансированные деревья поиска

+ **Задача 31**
     1. Условие:  Худший случай для красно-черных ДБП Объясните, как нужно построить красночерное
ДБП, демонстрирующее, что в худшем случае почти все пути от корня
до нулевой ссылки в красно-черном ДБП из N узлов имеют дnину 2 \gN.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_24)
	 3. Времени запланировано: 50 минут
	 4. Времени потрачено: 45 минут
+ **Задача 33**  
     1. Условие: Проверка. Добавьте в класс RedBlackBST метод is23() для выполнения проверки,
что ни у одного узла нет двух красных ссылок и нет правых красных
ссылок, и метод isBalanced() для выполнения проверки, что все пути от корня
к нулевым ссылкам содержат одинаковое количество черных ссылок. Объедините
эти методы с кодом isBST() из упражнения 3.2.32, чтобы получить метод
isRedBlackBST(), который проверяет, что дерево является красно-черным
деревом бинарного поиска.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_33)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 1 час
+ **Задача 39** 
     1. Условие: Удаление минимального. Реализуйте операцию deleteMin() для красно-черных
ДБП, используя преобразования, описанные в тексте, для спуска по левому
пути дерева и поддерживая инвариант, что текущий узел не является 2-узлом.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_39) 
	 3. Времени запланировано: 35 минут
	 4. Времени потрачено: 50 минут
+ **Задача 42** 
     1. Условие: Подсчет красных узлов. Напишите программу, которая вычисляет процент красных
узлов в заданном красно-черном ДБП. Проверьте работу программы, выполнив,
по крайней мере, 100 раз вставку N случайных ключей в первоначально
пустое дерево, для N = 104, 105 и 106, и сформулируйте гипотезу.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.3/task_42)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 50 минут

### 3.4 Хеш-таблицы

+ **Задача 4**
     1. Условие:  Напишите программу для определения значений a и m с наименьшим m, чтобы
хеш-функция (a * k) % m преобразования k-й буквы алфавита в индекс таблицы
давала различные значения (без коллизий) для ключей S E A R C H X M P L.
Такой результат называется идеальной хеш-функцией.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.4/task_4)
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 55 минут
+ **Задача 20**  
     1. Условие: Добавьте в класс LinearProbingHashST метод, который вычисляет среднюю
стоимость попадания в таблице, считая, что поиск может быть выполнен для
каждого ключа в таблице с равной вероятностью.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.4/task_20)
	 3. Времени запланировано: 35 минут
	 4. Времени потрачено: 1 час
+ **Задача 25** 
     1. Условие: Кеш хешей. Добавьте в код Transaction (листинг 3.4.2) переменную экземпляра
hash, в которой метод hashCode() может сохранить хеш-значение при первом
вычислении для каждого объекта, чтобы при последующих вызовах не тратить
время на повторное вычисление. Внимание: эта идея пригодна только для неизменяемых
типов.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.4/task__25) 
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 50 минут
+ **Задача 36** 
     1. Условие: Диапазон длин списков. Напишите программу, которая вставляет N ключей int в
таблицу размером N/100 с раздельными цепочками, а затем определяет длину
самого короткого и самого длинного списков, для N = 10^3, 10^4, 10^5 и 10^6.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_3.4/task_36)
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 45 минут

### 5.1 Сортировка строк

+ **Задача 7**
     1. Условие:  Разработайте реализацию распределяющего подсчета, в котором используется
массив объектов Queue.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.1/task_7)
	 3. Времени запланировано: 30 минут
	 4. Времени потрачено: 40 минут
+ **Задача 20**  
     1. Условие: Добавьте в класс LinearProbingHashST метод, который вычисляет среднюю
стоимость попадания в таблице, считая, что поиск может быть выполнен для
каждого ключа в таблице с равной вероятностью.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.1/task_20)
	 3. Времени запланировано: 35 минут
	 4. Времени потрачено: 1 час
+ **Задача 25** 
     1. Условие: Кеш хешей. Добавьте в код Transaction (листинг 3.4.2) переменную экземпляра
hash, в которой метод hashCode() может сохранить хеш-значение при первом
вычислении для каждого объекта, чтобы при последующих вызовах не тратить
время на повторное вычисление. Внимание: эта идея пригодна только для неизменяемых
типов.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.1/task__25) 
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 50 минут
+ **Задача 36** 
     1. Условие: Диапазон длин списков. Напишите программу, которая вставляет N ключей int в
таблицу размером N/100 с раздельными цепочками, а затем определяет длину
самого короткого и самого длинного списков, для N = 10^3, 10^4, 10^5 и 10^6.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.1/task_36)
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 45 минут

### 5.2 Trie-деревья

+ **Задача 5**
     1. Условие:  Разработайте реализацию распределяющего подсчета, в котором используется
массив объектов Queue.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.2/task_5)
	 3. Времени запланировано: 1 час
	 4. Времени потрачено: 1 час
+ **Задача 13**  
     1. Условие: Добавьте в класс LinearProbingHashST метод, который вычисляет среднюю
стоимость попадания в таблице, считая, что поиск может быть выполнен для
каждого ключа в таблице с равной вероятностью.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.2/task__13)
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 35 минут
+ **Задача 14** 
     1. Условие: Кеш хешей. Добавьте в код Transaction (листинг 3.4.2) переменную экземпляра
hash, в которой метод hashCode() может сохранить хеш-значение при первом
вычислении для каждого объекта, чтобы при последующих вызовах не тратить
время на повторное вычисление. Внимание: эта идея пригодна только для неизменяемых
типов.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.2/task__14) 
	 3. Времени запланировано: 20 минут
	 4. Времени потрачено: 25 минут
+ **Задача 22** 
     1. Условие: Печатающие мартышки. Допустим, что мартышка, печатающая на компьютере,
создает случайные слова, добавляя к текущему слову одну из 26 возможных ла- тинских букв
с вероятностью р и заканчивая слово с вероятностью 1-26р. На- пишите программу для оценки
распределения частот различных длин получен- ных слов. Если слово появилось несколько раз,
считайте его только один раз.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.2/task_22)
	 3. Времени запланировано: 30 минут
	 4. Времени потрачено: 45 минут

### 5.3 Поиск подстрок

+ **Задача 4** 
     1. Условие: Напишите эффективный метод, который принимает в качестве аргументов строку
txt и целое числом и возвращает позицию первого вхождения М последовательных пробелов в
строке или txt.length, если такого вхождения нет. Оцените количество сравнений символов,
которые выполняются в вашем методе для типичного текста и в худшем случае
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.3/task__4) 
	 3. Времени запланировано: 20 минут
	 4. Времени потрачено: 15 минут
+ **Задача 8**
     1. Условие: Добавьте в класс КМР метод count(), который подсчитывает вхождения
под-строки, и метод searchAll(), который выводит все вхождения.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.3/task_8)
	 3. Времени запланировано: 30 минут
	 4. Времени потрачено: 30 минут
+ **Задача 14**  
     1. Условие: Разработайте варианты реализаций поиска подстроки из данного раздела,
в которых для представления образца и текста применяется массив char[], а не тип String.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.3/task___14)
	 3. Времени запланировано: 35 минут
	 4. Времени потрачено: 45 минут
+ **Задача 26** 
     1. Условие: Проверка наличия цuклических перестановок. Напишите программу, которая для
заданных двух строк определяет, является ли одна из них циклической перестановкой
другой - например, пальто и топаль.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.3/task__26)
	 3. Времени запланировано: 10 минут
	 4. Времени потрачено: 5 минут

### 5.4 Регулярные выражения

+ **Задача 16** 
     1. Условие: Многочастное или. Добавьте в НКА многочастные операции или.
Ваш код должен сгенерировать для образца (.*АВ ((C|D|E)F)*G) машину, приведенную
 на рис. 5.4.8.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.4/task__16)
	 3. Времени запланировано: 35 минут
	 4. Времени потрачено: 30 минут
+ **Задача 17** 
     1. Условие: Обобщенные символы. Добавьте в класс NFA обработку обобщенных символов.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.4/task__17) 
	 3. Времени запланировано: 35 минут
	 4. Времени потрачено: 45 минут
 + **Задача 18**  
	 1. Условие: Один или несколько. Добавьте в класс NFA обработку операции замыкания +.	
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.4/task_18)
	 3. Времени запланировано: 40 минут
	 4. Времени потрачено: 50 минут
+ **Задача 21**
     1. Условие: Дополнение. Добавьте в класс NFA обработку оnисателей дополнения.
	 2. [Ссылка на задание :rewind:](https://github.com/SNEGIKON13/Java-Algorithms/tree/main/chapter_5.4/task_21)
	 3. Времени запланировано: 30 минут
	 4. Времени потрачено: 30 минут